/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const s=require("../utils/index.js"),g=require("@progress/kendo-recurrence"),D=require("@progress/kendo-date-math"),o=e=>e.charAt(0).toUpperCase()+e.slice(1),r=["first","second","third","fourth","last"],c=["never","daily","weekly","monthly","yearly"],d=[{day:0,offset:0},{day:1,offset:0},{day:2,offset:0},{day:3,offset:0},{day:4,offset:0},{day:5,offset:0},{day:6,offset:0}],i=[{day:1,offset:0},{day:2,offset:0},{day:3,offset:0},{day:4,offset:0},{day:5,offset:0}],u=[{day:0,offset:0},{day:6,offset:0}],b=e=>{switch(e){case"day":return d;case"weekday":return i;case"weekend":return u}},m=e=>g.parseRule({recurrenceRule:e})||{},h=e=>c.map(t=>({value:t,text:e("Frequencies"+o(t))})),p=e=>s.isPresent(e)&&!s.isNullOrEmptyString(e.freq)?e.freq:"never",R=e=>s.isPresent(e.until)?D.toLocalDate(e.until):null,w=e=>e.dateFormatNames({type:"months",nameType:"wide",standAlone:!0}).map((t,n)=>({text:t,value:n+1})),W=e=>{const t=e.firstDay(),n=e.dateFormatNames({type:"days",nameType:"abbreviated"}).map((y,a)=>({text:y,value:a}));return n.slice(t).concat(n.slice(0,t))},v=(e,t,n)=>e.find(y=>{let a;if(s.isPresent(t.byWeekDay))switch(t.byWeekDay.length){case 7:a="day";break;case 5:a="weekday";break;case 2:a="weekend";break;case 1:a=t.byWeekDay[0].day;break;default:a=n.getDay();break}return a===y.value})||e[0],F=(e,t)=>{const n=e.firstDay();let y=e.dateFormatNames({type:"days",nameType:"wide"}).map((l,k)=>({text:l,value:k}));const a=y.slice(n).concat(y.slice(0,n));return[{text:t("WeekdaysDay"),value:"day"},{text:t("WeekdaysWeekday"),value:"weekday"},{text:t("WeekdaysWeekendday"),value:"weekend"}].concat(a)},O=(e,t)=>e.find(n=>n.value===(t.bySetPosition?t.bySetPosition[0]:t.byWeekDay&&t.byWeekDay[0]?t.byWeekDay[0].offset:1))||e[0],S=e=>{const t=[1,2,3,4,-1];return r.map((n,y)=>({text:e("OffsetPositions"+o(n)),value:t[y]}))},P=e=>s.isPresent(e.count)?"count":s.isPresent(e.until)?"until":"never",E=e=>{if(s.isPresent(e.byWeekDay))return"weekday";if(s.isPresent(e.byMonthDay))return"monthday"},M=(e,t)=>e.find(n=>(t.byMonth?t.byMonth[0]:null)===n.value)||e[0],x=(e,t)=>s.isPresent(e.byMonthDay)&&e.byMonthDay.length>0?e.byMonthDay[0]:t.getDate();exports.FREQUENCIES=c;exports.OFFSET_POSITIONS=r;exports.capitalize=o;exports.dayRule=d;exports.getEndRule=P;exports.getExtendedWeekDays=F;exports.getFrequencies=h;exports.getFrequency=p;exports.getMonth=M;exports.getMonthDay=x;exports.getMonths=w;exports.getOffset=O;exports.getOffsets=S;exports.getRepeatOnRule=E;exports.getRule=m;exports.getUntil=R;exports.getWeekDay=v;exports.getWeekDays=W;exports.weekDayRuleFromString=b;exports.weekdayRule=i;exports.weekendRule=u;
